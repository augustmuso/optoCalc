# -*- coding: utf-8 -*-
"""Ret_arth.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OK7GVh95qs2uyfCLnec117rXSMZfII3q

### installs
"""

"""## imports"""

import numpy as np
import math
import plotly.graph_objects as go
from colour import Color

class RefractionPrescription:
    def __init__(self, Px=None, S=None, C=None, A=None, M=None, J45=None, J180=None, cross=None):
        if Px:
            self.Px = Px
            self.Px_to_SCA()
            self.SCA_to_PV()
            self.SCA_to_optical_cross()
        elif S is not None and C is not None and A is not None:
            self.S, self.C, self.A = S, C, A
            self.SCA_to_PV()
            self.SCA_to_optical_cross()
            self.SCA_to_Px()
        elif S is not None:
            self.S, self.C, self.A = S, 0.00, 180
            self.SCA_to_PV()
            self.SCA_to_optical_cross()
            self.SCA_to_Px()
        elif M is not None and J45 is not None and J180 is not None:
            self.M, self.J45, self.J180 = M, J45, J180
            self.PV_to_SCA()
            self.SCA_to_Px()
            self.SCA_to_optical_cross()
        elif cross is not None:
            self.cross = cross
            self.optical_cross_to_SCA()
            self.SCA_to_PV()
            self.SCA_to_Px()

    def SCA_to_Px(self):
        try:
            self.Px = f'{self.S:+.2f}/{self.C:+.2f}X{self.A}'
        except:
            print('Px not in SCA format')
            return None
        return f'{self.S:+.2f}DS/{self.C:+.2f}DCX{self.A}'

        
    def Px_to_SCA(self):
        if self.Px:
            self.Px = self.Px.replace(' ', '')\
                            .replace('DS', '')\
                            .replace('*', 'X')\
                            .replace('-', '-')\
                            .replace('x', 'X')\
                            .replace('DC', '')

            sphere_split = self.Px.split('/')
            cyl_split = sphere_split[1].split('X')

            if sphere_split[0].lower() == 'plano':
                self.S = 0.00
            else:
                self.S = float(sphere_split[0])

            if len(sphere_split) > 1:
                self.A = int(cyl_split[1])
                self.C = float(cyl_split[0])
            else:
                self.A = 0
                self.C = 0.00

        return self.S, self.C, self.A

    def PV_to_SCA(self):
        self.C = -2 * np.sqrt((self.J45 ** 2) + (self.J180 ** 2))
        self.S = self.M - (self.C / 2)

        _A = np.round((1 / 2) * math.degrees(math.atan2(self.J45, self.J180)))
        self.A = int(_A) if _A >= 0.04 else int(180 + _A)

        return self.S, self.C, self.A

    def SCA_to_PV(self):
        self.J45 = -(self.C / 2) * math.sin(math.radians(2 * self.A))
        self.M = self.S + (self.C / 2)
        self.J180 = -(self.C / 2) * math.cos(math.radians(2 * self.A))

        return self.M, self.J45, self.J180

    def SCA_to_optical_cross(self):
        sp_up = self.S
        sp_down = self.S + self.C
        ax_sp_up = self.A
        ax_sp_down = 90 + ax_sp_up if ax_sp_up <= 90 else ax_sp_up - 90
        self.cross = np.array([[sp_up, sp_down], [ax_sp_up, ax_sp_down]])

        return self.cross

    def cross_to_SCA(self):
        self.S = self.cross[0, 0]
        self.C = self.cross[0, 0] - self.cross[0, 1]
        self.A = self.cross[1, 0]

        return self.S, self.C, self.A

    def cross_plot(self):
        # Implementation
        pass

    def axis_power(self, Axis):
        pwr = self.S + self.C * (math.sin(math.radians(2 * (Axis - self.A))))
        b = np.array([[pwr, Axis]])
        self.cross = np.concatenate([self.cross, b.T], axis=1)

        return pwr, self.cross

    def __add__(self, other):
        newM = self.M + other.M
        newJ45 = self.J45 + other.J45
        newJ180 = self.J180 + other.J180

        newPx = RefractionPrescription(M=newM, J45=newJ45, J180=newJ180)
        return newPx

    def __sub__(self, other):
        newM = self.M - other.M
        newJ45 = self.J45 - other.J45
        newJ180 = self.J180 - other.J180

        newPx = RefractionPrescription(M=newM, J45=newJ45, J180=newJ180)
        return newPx

    def average(self, other):
        newM = (self.M + other.M) / 2
        newJ45 = (self.J45 + other.J45) / 2
        newJ180 = (self.J180 + other.J180) / 2

        newPx = RefractionPrescription(M=newM, J45=newJ45, J180=newJ180)
        return newPx

    def __radd__(self, other):
        if other == 0:
            return self
        else:
            return self.__add__(other)

